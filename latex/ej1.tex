\section{Ejercicio 1: Una nueva esperanza}

    % Describir detalladamente el problema a resolver dando ejemplos del mismo
    % y sus soluciones.
    \subsection{Descripción del problema}

    \begin{figure}[ht]
        \begin{center}
            \includegraphics[width=10cm]{imagenes/una_nueva_esperanza.jpg}
            \caption*{``Ese lugar... es fuerte con el lado oscuro de la Fuerza. Un
            dominio del mal es. Dentro tú debes ir.''}
        \end{center}
    \end{figure}

    Como parte de su entrenamiento con el maestro Yoda, Luke Skywalker debe
    recorrer un complejo sistema que consta de $N$ cuevas, conectadas por $M$
    pasadizos. Cada pasadizo une dos cuevas entre sí, formando una red en la
    que siempre existe una forma de llegar desde una cueva hasta cualquier
    otra. Además, no todos los pasadizos son iguales: algunos de ellos son
    especiales, y para atravesarlos Luke deberá enfrentarse a sus mayores
    miedos. Recorrer cualquier pasadizo le demanda a Luke exactamente un
    minuto.

    Partiendo de una cueva etiquetada con el número $0$, Luke debe llegar en
    el menor tiempo posible a la cueva número $N-1$, donde lo espera Yoda.
    Sin embargo, su entrenamiento no estará completo hasta no haber pasado al
    menos por dos pasadizos especiales. Está permitido recorrer el mismo
    pasadizo más de una vez.

    Se pide implementar un algoritmo que determine el menor tiempo posible que
    le demandará a Luke completar su entrenamiento, y la secuencia de cuevas
    que deberá recorrer para lograrlo, con una complejidad temporal de
    $\ord(N + M)$.

    \vspace{1.25em}

    \textbf{Formato de entrada}: La primera línea consta de un entero positivo
    \texttt{N}, que indica la cantidad de cuevas, y un entero positivo
    \texttt{M}, que indica la cantidad de pasadizos. A continuación de esta
    línea siguen \texttt{M} líneas con enteros \texttt{Ai}, \texttt{Bi} y
    \texttt{Ei}, cada una de ellas correspondiente a un pasadizo, donde
    \texttt{Ai} y \texttt{Bi} son enteros (entre $0$ y $N-1$ inclusive) que
    indican los extremos del mismo, mientras que \texttt{Ei} indica
    el tipo de pasadizo ($0$ para los pasadizos comunes y $1$ para los
    especiales). Es decir, el formato de la entrada es el siguiente:

    \begin{verbatim}
    N M
    A0 B0 E0
    A1 B1 E1
    ...
    AM-1 BM-1 EM-1\end{verbatim}

    \vspace{.8em}

    \textbf{Formato de salida}: Debe devolverse una primera línea conteniendo
    la cantidad de minutos (\texttt{T}) que durará el entrenamiento de Luke,
    y una segunda línea con la lista ordenada de las cuevas (\texttt{I1},
    \texttt{I2}, \dots, \texttt{I(T-1)}) que deberá recorrer para
    completarlo, omitiendo la salida desde la cueva $0$ y la llegada a la
    cueva $N-1$. El formato requerido es el siguiente:

    \begin{verbatim}
    T
    I1 I2 ... I(T-1)\end{verbatim}

    \vspace{.8em}

    A continuación se incluyen, a modo de ejemplo, una posible entrada y una
    salida correcta para la misma:

    \vspace{.5em}
    \begin{tabular}{l @{\hskip 4em} l}
    \textbf{Entrada} & \textbf{Salida} \\
    \texttt{5 6}     & \texttt{3}      \\
    \texttt{0 1 0}   & \texttt{2 3}    \\
    \texttt{0 2 1}   &                 \\
    \texttt{0 4 0}   &                 \\
    \texttt{1 3 0}   &                 \\
    \texttt{2 3 0}   &                 \\
    \texttt{3 4 1}   &                 \\
    \end{tabular}
    \vspace{.5em}

    Es importante observar que puede haber más de una salida distinta válida.

    % Explicar de forma clara, sencilla, estructurada y concisa, las ideas
    % desarrolladas para la resolución del problema. Utilizar pseudocódigo y
    % lenguaje coloquial (no código fuente). Justificar por qué el
    % procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}

	\subsubsection{Modelo}

	Para resolver este problema se exigía encontrar el camino que recorriera al
	menos 2 pasillos especiales con un costo mínimo de tiempo, donde el mismo se
	define como el total de pasillos atravesados. Lo primero que se realizó fue
	modelar el problema con grafos dado que el mismo tenía características que
	sugerían que para la resolución iba a ser necesario calcular un camino mínimo de algún tipo.

	La primer idea de representación con grafos fue tener las cuevas como nodos y
	los pasillos como aristas. Sin embargo, quedaban aquí sin contemplar los
	pasillos especiales. Para subsanar esto, cada arista contiene además una bandera
	indicando si es o no un pasillo especial.

	Este grafo era una forma de modelar el problema donde aún no quedaba claro
	cómo resolver el ejercicio. Si se buscaba el camino mínimo del punto inicial
	al resto de las cuevas no existía ninguna garantía de que se cumpliera la
	condición de haber recorrido al menos 2 pasillos especiales.

	Para la versión final del modelo, lo que se hizo fue generar copias del
	grafo descrito anteriormente, teniendo como diferencia entre estos su
	\emph{estado}. El estado lo que indicará es para cada una de estas copias la
	cantidad de caminos especiales recorridos.

	Se tienen tres grafos, uno para cada uno de los siguientes estados:

	\begin{enumerate}
		\item{No se recorrió ningún pasillo especial.}
		\item{Se recorrió un pasillo especial.}
		\item{Se recorrieron al menos dos pasillos especiales.}
	\end{enumerate}

	\begin{figure}[H]
		\centering
		\includegraphics{imagenes/ej1_modelo_1.pdf}
		\caption{Visualización de los grafos con las aristas rojas representando un pasillo especial.}
		\label{ej1:fig_1}
	\end{figure}

	Una posible observación es que por más que cada grafo representa el mismo
	conjunto de cuevas y pasillos, para cada estado se utilizan
	números distintos para identificar cada nodo. Esto se debe a que ésta será
	la forma de identificar en qué estado se encuentra cada nodo. Se define la
	siguiente función donde $V$ es el número de nodo y $N$ el total de cuevas
	dado por la entrada:

	\begin{equation*}
		estado(V) =
		\begin{cases}
			1 & , V \leq N \\
			2 & , N < V \leq 2 * N \\
			3 & , 2 * N < V \leq 3 * N
		\end{cases}
	\end{equation*}

	Teniendo esta representación, se procede a explicar el algoritmo y
	solución desarrollada. Existen dos objetivos: que Luke atraviese al menos 2
	caminos especiales, que el camino que tome para lograr eso sea mínimo. Para
	lo segundo, como las aristas no poséen pesos, se puede utilizar
	\emph{Breadth First Search}, que permite obtener la distancia de un nodo
	cualquiera hacia el resto. Sin embargo esto solo no alcanza, ya que es
	requisito el recorrer al menos 2 caminos especiales. Para cumplir con esta
	condición se introduce una ligera modificación al \emph{BFS}: si un vecino
	se accede cruzando un pasillo especial, el nodo correspondiente en el estado
	siguiente se marca como visitado y se encolan sus vecinos.

	De esta manera lo que se logra es que en cuanto se realiza un cambio de
	estado (el salto a un vecino mediante un pasillo especial), se permite que
	el \emph{BFS} recorra cuevas que ya había visitado, con la diferencia de que
	cuenta con el hecho de que atravesó al menos un pasillo especial.

	Siguiendo esta lógica se obtiene la distancia de una cueva al resto en
	alguno de sus posibles estados. En particular, tomando el grafo
	correspondiente al estado donde se recorrieron al menos 2 pasillos
	especiales, la distancia hasta el nodo que equivale al $N - 1$ es la del camino mínimo
	pedido por el enunciado.

	A continuación se presenta el efecto de cada iteración del algoritmo sobre el grafo
	presentado en la Figura \ref{ej1:fig_1}:

	\begin{figure}[H]
		\centering
		\includegraphics{imagenes/ej1_modelo_2.pdf}
		\caption{Visualización del \emph{BFS} marcando con verde los nodos
		visitados.}
		\label{ej1:bfs}
	\end{figure}

	Esta ejecución genera el siguiente árbol de caminos mínimos, donde se puede
	observar que se obtiene la distancia al nodo 12 que es el equivalente al $N
	- 1$ en el grafo donde se recorrieron al menos 2 pasillos especiales:

	\begin{figure}[H]
		\centering
		\includegraphics{imagenes/ej1_modelo_3.pdf}
		\caption{Árbol de caminos mínimos del nodo inicial al resto.}
	\end{figure}

	Una vez que se tiene este árbol de caminos mínimos, para armar la solución se trepa
	desde el nodo $N - 1$ (con $estado(N - 1) = 3$) hasta la
	raiz, traduciendo el índice de cada nodo al de su equivalente en el grafo
	original. Por ejemplo, el nodo 12 es en realidad la cueva 4 con $estado(12) =
	3$, por lo tanto a la hora de armar el camino se lo traducirá a 4.

    A continuación se exhibe el pseudocódigo del algoritmo que resuelve el problema:

    \begin{algorithm}
        \caption{BFS modificado}
        \label{algo:bfs}

        \Input{Un entero $N$ y un grafo $G$ de $N$ nodos y $M$ aristas, dado por un vector de
        listas de adyacencia}
        \Output{El camino mínimo entre el nodo 0 y el $N - 1$, pasando por al menos dos 
        pasadizos especiales, dado como una pila de enteros}
        $predecesores$ $\gets$ vector de longitud $3N$ con cada valor en $sinPadre$ \;
        $colaNodos$ $\gets$ cola de enteros vacía \;
        $predecesores$[$0$] $\gets$ $0$ \;
        $colaNodos$.encolar($0$) \;

        \While{$colaNodos$ no esté vacía} {
            $nodo$ $\gets$ $colaNodos$.desencolar() \;
            $nodoEfectivo$ $\gets$ índice real de $nodo$ \;
            \ForEach{vecino $v$ de $nodoEfectivo$}{
                $nodoAdyacente$ $\gets$ $v$ + diferencia de estado entre $nodo$ y $nodoEfectivo$ \;
                \If{hay camino especial entre $nodoEfectivo$ y $v$} {
                    cambiar de estado a $nodoAdyacente$, tiene un camino especial mas \;
                }
                \If{$predecesores$[$nodoAdyacente$] == $sinPadre$} {
                    $predecesores$[$nodoAdyacente$] $\gets$ $nodo$ \;
                    $colaNodos$.encolar($nodoAdyacente$) \;
                }
            }
        }

        $caminoOptimo$ $\gets$ pila de enteros vacía \;
        $actual$ $\gets$ nodo $N - 1$ con estado $alMenosDosCaminosEspeciales$ \;
        \While{$actual$ sea distinto del nodo 0} {
            $caminoOptimo$.apilar(indice real de $actual$) \;
            $actual$ $\gets$ $predecesores$[$actual$] \;
        }
        \Return{$predecesores$}
    \end{algorithm}

	Habiendo introducido la idea detrás de la solución desarrolada, se procede a
	demostrar que esto efectivamente funciona, es decir que con esta
	modificación al \emph{BFS} siempre se encontrará un camino mínimo hasta la
	cueva $N - 1$ habiendo recorrido al menos 2 pasillos especiales.

	\subsubsection{Demostración de correctitud}

	Para probar que se cumple lo pedido, primero se realizará inducción sobre los ciclos
	del \emph{BFS} modificado buscando demostrar que al finalizar, se obtienen
	los caminos mínimos teniendo en cuenta la condición de pasadizos especiales
	recorridos.

	\subsubsection*{Correctitud del ciclo}

	El invariante a demostrar será el siguiente: al terminar el ciclo $k$ del
	\emph{BFS} modificado se obtienen todos los nodos a distancia a lo sumo
	$k$ del inicial en alguno de los estados posibles. Esto se probará
	mediante inducción en los ciclos del algoritmo.

	~

	\textbf{Caso base: } $k = 1$

	En el caso base se tiene únicamente el nodo inicial marcado como
	visitado con distancia 0. Como se trata del nodo inicial, se encuentra en el primer estado ya que
	no se recorrieron pasadizos especiales. Por lo tanto, existen dos posibles
	formas de accionar con respecto a sus vecinos:

	\begin{enumerate}
		\item{
			El vecino está conectado mediante un pasadizo común, con lo cual en
			el grafo del nodo inicial se lo marca con distancia 1 y encolan sus
			vecinos.
		}
		\item{
			El vecino está conectado mediante un pasadizo especial, por lo tanto
			en el grafo en el estado siguiente, es decir en el que se cuenta con
			que se recorrió un pasadizo especial, se lo marca con distancia 1 y
			encolan sus vecinos.
		}
	\end{enumerate}

	De esta forma una vez finalizada la iteración $k = 1$ se obtienen todos los
	nodos que están a distancia 1 del nodo inicial.

	~

	\textbf{Paso inductivo: } $k > 1$

	Como hipótesis inductiva se cuenta con que vale el invariante para $k - 1$,
	por lo tanto se tiene la distancia para todos los nodos a lo sumo
	a distancia $k - 1$ para alguno de los estados descritos y además se
	tienen encolados para visitar los que están a distancia $k$.

	Ahora acá existen distintas posibilidades por el hecho de que a diferencia
	del caso base, los nodos encolados no tienen por qué necesariamente
	encontrarse en el primer estado. Pueden haber nodos pertenecientes al
	segundo como tercer estado (un pasadizo especial o al menos dos recorridos).

	Es entonces necesario probar que en cada caso el invariante seguirá
	valiendo:

	\begin{enumerate}
		\item{
			El nodo encolado pertenece al primer estado. En este escenario, al
			igual que con el caso base existen dos posibles formas de operar en
			función de si se accede a un vecino mediante una arista especial:

			\begin{enumerate}
				\item{
					El vecino está conectado mediante un pasadizo común, con lo
					cual en el grafo del primer estado se observa si ya se
					encuentra marcado. En caso de no estar marcado, en ese
					mismo grafo se le asigna la distancia $k$ y encolan sus
					vecinos.
				}
				\item{
					El vecino está conectado mediante un pasadizo especial, con
					lo cual en el grafo del segundo estado se observa si ya se
					encuentra marcado. En caso de no estar marcado en ese mismo
					grafo se le asigna la distancia $k$ y encolan sus vecinos.
				}
			\end{enumerate}
		}
		\item{
			El nodo encolado pertence al segundo estado. Nuevamente existen dos
			posibles formas de operar en función de si la arista que lo conecta
			a un vecino es especial:

			\begin{enumerate}
				\item{
					El vecino está conectado mediante un pasadizo común, con lo
					cual en el grafo del segundo estado se observa si ya se
					encuentra marcado. En caso de no estar marcado, en ese mismo
					grafo se le asigna distancia $k$ y encolan sus vecinos.
				}
				\item{
					El vecino está conectado mediante un pasadizo especial, con
					lo cual en el grafo del tercer estado se observa si ya se
					encuentra marcado. En caso de no estar marcado en ese mismo
					grafo se le asigna la distancia $k$ y encolan sus vecinos.
				}
			\end{enumerate}
		}
		\item{
			Por último, en caso de que el nodo encolado pertenezca al tercer
			estado existe una única manera de proceder, ya que en caso de que un
			vecino se encuentre conectado mediante una arista especial ya no hay
			un estado sucesor.

			Si en el grafo del tercer estado alguno de los vecinos no se
			encuentra marcado, se le asigna distancia $k$ y es encolado para ser
			visitado.
		}
	\end{enumerate}

	Habiendo contemplado cada escenario posible es posible afirmar que al
	finalizar la iteración $k$ con $k > 2$ se obtienen todos los nodos a
	distancia $k$ para alguno de los estados posibles.

	Por inducción en los ciclos del algoritmo, se demuestra que para
	toda iteración se cumple el invariante, con lo cual al finalizar se obtiene
	la distancia de todos los nodos para alguno de los estados descritos.

	Queda probar entonces que si existe al menos una arista especial entonces
	siempre se obtendrá la distancia hasta el nodo $N - 1$ en el tercer estado,
	es decir el mínimo camino tal que se atraviesan al menos dos caminos
	especiales.

	Para probar que esto vale, se demostrará que el grafo vinculado al tercer
	estado, tendrá todos sus nodos marcados con su respectiva distancia.

	\subsubsection*{Existencia de un camino mínimo al nodo $N - 1$ en el tercer
	estado}

	Como se dijo previamente, se probará que todo nodo pertenciente al tercer
	estado se encuentra marcado con su respectiva distancia. Supongamos que esto
	no es cierto, que existe al menos un nodo sin marcar. Esto podría ser
	resultado de uno de los siguientes escenarios:

	\begin{itemize}
		\item{Nunca se salta al tercer estado, en este caso resultando en que no
			haya ningún nodo marcado en el mismo.}
		\item{Se llega al tercer estado pero no se recorren todos sus nodos.}
	\end{itemize}

	Si se considera el primer escenario, esto implica que jamás se saltó del
	segundo al tercer estado. Sin embargo para que esto ocurriese se debería
	cumplir una de las siguientes condiciones: jamás se saltó al segundo estado
	o ningún nodo del segundo estado tiene un vecino conectado mediante una
	arista especial. Es fácil ver que ninguna de estas condiciones se cumplen.

	La primera, como se asume que siempre existe al menos un pasadizo especial,
	por el comportamiento del \emph{BFS} modificado eventualmente se
	encontrará un nodo cuyo vecino está conectado por una arista especial y en el
	grafo del segundo estado este vecino no estará marcado, con lo cual lo
	marcará y encolará sus vecinos saltando de esta forma al segundo estado.

	Lo segundo, que ningún nodo del segundo estado tenga un vecino conectado
	mediante un pasadizo especial, carece de sentido por el hecho de que el
	grafo vinculado con el segundo estado es una copia del primero. Entonces, si
	del primero se salta al segundo, en este estado el nodo seguro tendrá como
	vecino el nodo del que saltó, también conectado mediante una arista
	especial.

	Por lo tanto habiendo visto que ninguna de estas condiciones se cumplen
	queda demostrado que el primer escenario nunca puede suceder, ya que si se
	llega al segundo estado y además se cuenta con que habrán vecinos conectados
	mediante aristas especiales esto significa que van a existir saltos al
	tercer estado.

	Queda entonces el segundo escenario, se llega al tercer estado pero no se
	recorren todos sus nodos. Esto es algo que podría suceder en el primer o
	segundo estado (véase Figura \ref{ej1:bfs}) pero no en el tercero.

	Si quedan nodos sin marcar en el tercer grafo es porque los mismos jamás
	fueron encolados para visitarlos. Ya se demostró que al tercer estado se
	salta en algún momento, con lo cual al menos uno de los nodos de
	seguro va a estar marcado. Luego por la descripción del \emph{BFS}
	modificado tenemos que un nodo en el tercer estado ya no salta a otro grafo,
	con lo cual todos los vecinos no marcados son visitados. De esta forma no
	hay manera que queden nodos sin visitar, ya que o bien están marcados de
	forma directa como vecinos de un nodo del segundo estado, o son alcanzados por
	el avance del \emph{BFS} de alguno de los nodos provenientes de un salto del segundo estado.

	Así se prueba entonces que ninguno de los escenarios planteados pueden
	suceder, con lo cual todos los nodos en el tercer estado están marcados y
	poséen un camino mínimo hasta el nodo inicial en el primer estado. Como
	consecuencia de esto, en particual de seguro existe un camino mínimo del
	nodo incial en el primer estado al nodo $N - 1$ en el tercer estado.

    % Deducir una cota de complejidad temporal del algoritmo propuesto (en
    % función de los parámetros que se consideren correctos) y justificar por
    % qué el algoritmo la cumple. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}
    Crear el vector de representación para los estados de los nodos tiene un
	costo de $\ord(3N)$.

	En el peor caso, el \emph{BFS} va a marcar todos los nodos en cada estado
	posible. Este escenario implica que para cada nodo en todos sus posibles
	estados tendrá que consultar si alguno de sus vecinos se encuentra o no
	marcado. Esto resulta en la suma de los grados de todos los nodos:

	\begin{equation*}
		\ord(\sum_{i=1}^{n=3 N} d(v_i)) = \ord(2 \times 3M) = \ord(6M)
	\end{equation*}

	Por último se arma el camino óptimo trepando del nodo destino $N - 1$ en el
	tercer estado hasta el nodo origen en estado inicial. Esto en el peor caso
	resulta en un camino con $3N$ nodos, que es la longitud del mayor camino
	simple posible. Por lo tanto para la construcción del camino óptimo se
	tiene $\ord(3N)$.

	La complejidad total queda $\ord(6N + 6M) = \ord(N + M)$ donde al ser el
	grafo conexo se cumple que $M \geq N - 1$, con lo cual la cota final resulta $\ord(M)$.

    % Realizar experimentación para medir la performance, usando un conjunto
    % de casos de test que permitan observar los tiempos de ejecución en
    % función de los parámetros de entrada, tanto para instancias aleatorias
    % (detallando cómo fueron generadas) como para instancias particulares
    % (peor/mejor caso, por ejemplo). Presentar en forma gráfica una
    % comparación entre los tiempos medidos y la complejidad teórica y extraer
    % conclusiones.
    \subsection{Experimentación}

    Una vez completada la implementación de la solución, se llevaron a cabo
    pruebas experimentales con el objetivo de verificar que se cumpliera la
    cota teórica prevista para la complejidad asintótica de $\ord(M)$, siendo
    $M$ la cantidad de aristas del grafo tomado como entrada.

    Las pruebas realizadas pueden dividirse en dos grupos. Por un lado, se
    midió el tiempo de ejecución para diferentes familias de instancias
    generadas de forma aleatoria, para corroborar así que en todas ellas la
    complejidad mostrara el comportamiento previsto. Por otra parte, se
    llevaron a cabo pruebas soporte de las anteriores, para confirmar
    hipótesis acerca de la relación entre el rendimiento temporal del
    algoritmo y la modificación de ciertas variables de los datos de entrada.

    \subsubsection{Experimentos principales}

    \newcommand\constante{300}

    Se construyeron generadores de escenarios de prueba aleatorios para distintas
    instancias del problema, permitiendo modificar el parámetro $M$, es decir,
    la cantidad de aristas de los grafos generados. Se procuró que las familias
    de grafos generadas para cada escenario resultaran \emph{coherentes}, en
    el sentido de que se intentó que la complejidad de su resolución dependiera
    solo de la cantidad de aristas y no de otros factores inherentes a su
    construcción.

    Un factor que resultó especialmente complejo fue la distribución de las
    aristas especiales en los grafos generados. Se decidió, entre las alternativas
    posibles, generar a los grafos con una proporción fija $p$ de aristas
    especiales sobre el total de aristas, elegidas al azar; es decir, durante
    la generación de las instancias, cada arista que se agrega se marca como
    especial con una probabilidad de $p$. De esta manera se intenta
    homogeneizar las instancias tanto como sea posible. En las pruebas
    adicionales, se experimenta con el efecto que tienen diversos valores de
    $p$ sobre el tiempo de ejecución del algoritmo; en estas pruebas, se
    utilizó un valor fijo de $p = 0.3$.

    A continuación se detallan las características de los distintos escenarios
    generados, junto con la notación utilizada en los gráficos para referirse
    a los mismos.
    \begin{itemize}
        \item $T_r$: Árboles generados de forma aleatoria. Para cada valor de
        $M$, se genera un grafo de $N = M+1$ nodos. A continuación, se van
        agregando aristas al grafo de forma aleatoria, asegurándose de que no
        se formen ciclos, hasta completar $M$ aristas. La metodología para
        hacerlo es similar al algoritmo de Prim: en cada paso se elige al azar
        un nodo que ya forme parte del árbol y uno que no, y se los conecta
        por medio de una arista.
        \item $T_i$: Árboles generados de forma incremental. Para el primer
        valor de $M$ considerado, se genera un árbol según la metodología
        anterior. Para los valores de $M$ siguientes, se considera el grafo
        generado para el valor previo, completándolo a $M+1$ nodos y agregando
        aristas de forma aleatoria hasta formar un nuevo árbol con $M$
        aristas.
        \item $K$: Grafo completo. Para cada valor de $M$ se considera un
        grafo completo con $\frac{1 + \sqrt{1 + 8 \times M}}{2}$ nodos. Los
        valores de $M$ considerados se seleccionan de forma tal que el
        resultado de esta fórmula sea un número entero. En este caso, al
        igual que en los dos siguientes, el elemento de azar se
        reduce a la selección del subconjunto de aristas especiales.
        \item $P$: Camino simple de $M$ aristas, cuyos extremos son los nodos 
        $0$ y $N-1$.
        \item $A$: Árbol $M$-ario completo de $M$ aristas. Se construye un
        árbol donde el nodo $0$ resulta adyacente a todos los demás.
    \end{itemize}

    Cabe destacar que el escenario $K$ tiene una cantidad de nodos
    considerablemente menor que todos los demás (del orden de $\sqrt{M}$
    frete a $M$), lo cual hace esperable que su tiempo de ejecución resulte
    también relativamente menor. No obstante, los escenarios $P$ y $A$ se ven
    favorecidos por la simpleza de su resolución.
    % CHAMUYAR ALGO ACÁ. En el caso $A$, dado que
    % todos los nodos están unidos al nodo $0$, son encolados juntos durante la
    % primera iteración del algoritmo. Luego se itera sobre ellos sin volver a
    % agregar nodos a la cola, . En el caso $P$, se da la situación opuesta,
    % dado que
    % Los dos escenarios con árboles aleatorios ($T_r$ y $T_i$), por su parte,
    % además de tener una cantidad de nodos del orden de $M$, pueden requerir
    % gran cantidad de 

    En la Figura \ref{fig:exp1:var-m-base} pueden observarse los resultados
    del tiempo de ejecución observado para todos los escenarios, considerando
    valores de $M$ entre $20000$ y $800000$. Se ilustra también la cota
    teórica mediante una función lineal $c \times M$; el valor de $c$
    utilizado es $\constante$.

    \begin{figure}[H]
        \centering
        \caption{}
        \label{fig:exp1:var-m-base}
        \begin{tikzpicture}
            \begin{axis}[
                    title={},
                    xlabel={Tamaño de entrada ($M$)},
                    ylabel={Tiempo de ejecución (nanosegundos)},
                    scaled x ticks=false,
                    scaled y ticks=false,
                    enlargelimits=0.05,
                    width=0.5\textwidth,
                    height=0.5\textwidth,
                    legend pos=outer north east,
                    legend cell align=left,
                    xmin=1
                ]
                \addplot[color=darkgray]
                    table[x index=0, y expr={x*\constante}]
                    {../exp/UnaNuevaEsperanza-varM-arboles};
                \addplot[color=red]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-varM-inc-arboles};
                \addplot[color=orange]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-varM-arboles};
                \addplot[color=green]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-varM-completos};
                \addplot[color=blue]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-varM-caminos};
                \addplot[color=violet]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-varM-m-arios};
                \legend{$c \times M$, $T_{T_i}$, $T_{T_r}$, $T_{K}$, $T_{P}$,
                $T_{A}$}
            \end{axis}
        \end{tikzpicture}
    \end{figure}

    En la Figura \ref{fig:exp1:var-m-div-const} se ilustra el resultado de
    dividir todos los tiempos observados por su correspondiente valor de $M$.
    Puede notarse claramente que el crecimiento de todas las funciones
    observadas queda acotado por la constante $c$, corroborando en forma
    empírica la complejidad de $\ord(M)$ estimada en forma teórica.

    \begin{figure}[H]
        \centering
        \caption{}
        \label{fig:exp1:var-m-div-const}
        \begin{tikzpicture}
            \begin{axis}[
                    title={},
                    xlabel={Tamaño de entrada ($M$)},
                    ylabel={Tiempo de ejecución (nanosegundos)},
                    scaled x ticks=false,
                    scaled y ticks=false,
                    enlargelimits=0.05,
                    width=0.5\textwidth,
                    height=0.5\textwidth,
                    legend pos=outer north east,
                    legend cell align=left,
                    xmin=1
                ]
                \addplot[color=darkgray]
                    table[x index=0, y expr={\constante}]
                    {../exp/UnaNuevaEsperanza-varM-arboles};
                \addplot[color=red]
                    table[x index=0,y expr={\thisrowno{1} / x}]
                    {../exp/UnaNuevaEsperanza-varM-inc-arboles};
                \addplot[color=orange]
                    table[x index=0,y expr={\thisrowno{1} / x}]
                    {../exp/UnaNuevaEsperanza-varM-arboles};
                \addplot[color=green]
                    table[x index=0,y expr={\thisrowno{1} / x}]
                    {../exp/UnaNuevaEsperanza-varM-completos};
                \addplot[color=blue]
                    table[x index=0,y expr={\thisrowno{1} / x}]
                    {../exp/UnaNuevaEsperanza-varM-caminos};
                \addplot[color=violet]
                    table[x index=0,y expr={\thisrowno{1} / x}]
                    {../exp/UnaNuevaEsperanza-varM-m-arios};
                \legend{$c$, $T_{A_i}/M$, $T_{A_r}/M$, $T_{C}/M$, $T_{P}/M$, $T_{K}/M$}
            \end{axis}
        \end{tikzpicture}
    \end{figure}

    \subsubsection{Experimentos adicionales}

    Como se mencionó anteriormente, una de las cualidades deseables en las
    familias de grafos elegidas para realizar los experimentos es que la
    complejidad de su resolución no se vea afectada por variables externas al
    experimento y que resulten imposibles de controlar. Esto resulta
    especialmente difícil de verificar en el caso de las instancias generadas
    de forma totalmente aleatoria, como sucede con el escenario $T_r$. Es por
    esto que se decidió realizar, en forma complementaria, una prueba
    experimental para corroborar que diferentes grafos generados de esta forma
    no produjeran tiempos de ejecución excesivamente diferentes para idénticos
    valores de $M$.

    Para esto, se seleccionaron cuatro valores de $M$, $100000$, $2000000$,
    $400000$ y $800000$, y para todos ellos se generaron $200$ grafos
    distintos utilizando los procedimientos aleatorios antes descriptos, para
    los escenarios $T_r$ y $K$. Así, se logró verificar que las instancias
    generadas para estos escenarios se comportan de una forma uniforme,
    validando su utilización en el experimento anterior.

    La Figura \ref{fig:exp1:aleatorios-arb} muestra los resultados obtenidos
    para el escenario $T_r$ (árboles), mientras que la Figura
    \ref{fig:exp1:aleatorios-comp} hace lo propio con el escenario $K$ 
    (grafos completos).

    \begin{figure}[H]
        \centering
        \caption{}
        \label{fig:exp1:aleatorios-arb}
        \begin{tikzpicture}
            \begin{axis}[
                    title={},
                    mark size=1pt,
                    xlabel={Número de instancia},
                    ylabel={Tiempo de ejecución (nanosegundos)},
                    scaled x ticks=false,
                    scaled y ticks=false,
                    enlargelimits=0.05,
                    width=0.5\textwidth,
                    height=0.5\textwidth,
                    legend pos=outer north east,
                    legend cell align=left,
                    xmin=1
                ]
                \addplot[color=blue,only marks]
                    table[x expr=\coordindex, y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-arb-m100k};
                \addplot[color=green,only marks]
                    table[x expr=\coordindex, y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-arb-m200k};
                \addplot[color=orange,only marks]
                    table[x expr=\coordindex, y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-arb-m400k};
                \addplot[color=red,only marks]
                    table[x expr=\coordindex,y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-arb-m800k};
                \legend{$M = 100000$, $M = 200000$, $M = 400000$, $M = 800000$}
            \end{axis}
        \end{tikzpicture}
    \end{figure}

    \begin{figure}[H]
        \centering
        \caption{}
        \label{fig:exp1:aleatorios-comp}
        \begin{tikzpicture}
            \begin{axis}[
                    title={},
                    mark size=1pt,
                    xlabel={Número de instancia},
                    ylabel={Tiempo de ejecución (nanosegundos)},
                    scaled x ticks=false,
                    scaled y ticks=false,
                    enlargelimits=0.05,
                    width=0.5\textwidth,
                    height=0.5\textwidth,
                    legend pos=outer north east,
                    legend cell align=left,
                    xmin=1
                ]
                \addplot[color=blue,only marks]
                    table[x expr=\coordindex, y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-comp-m100k};
                \addplot[color=green,only marks]
                    table[x expr=\coordindex, y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-comp-m200k};
                \addplot[color=orange,only marks]
                    table[x expr=\coordindex, y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-comp-m400k};
                \addplot[color=red,only marks]
                    table[x expr=\coordindex,y index=1]
                    {../exp/UnaNuevaEsperanza-aleatorios-comp-m800k};
                \legend{$M = 100000$, $M = 200000$, $M = 400000$, $M = 800000$}
            \end{axis}
        \end{tikzpicture}
    \end{figure}

    \begin{figure}[H]
        \centering
        \caption{}
        \label{fig:exp1:aristas-esp}
        \begin{tikzpicture}
            \begin{axis}[
                    title={},
                    xlabel={Proporción de aristas especiales ($c$)},
                    ylabel={Tiempo de ejecución (nanosegundos)},
                    scaled x ticks=false,
                    scaled y ticks=false,
                    width=0.5\textwidth,
                    height=0.5\textwidth,
                    legend pos=north east,
                    legend cell align=left,
                ]
                \addplot[color=red]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-aristas-esp-arb-m200k};
                \addplot[color=blue]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-aristas-esp-comp-m200k};
                \addplot[color=red]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-aristas-esp-arb-m400k};
                \addplot[color=blue]
                    table[x index=0,y index=1]
                    {../exp/UnaNuevaEsperanza-aristas-esp-comp-m400k};
                \legend{Árboles aleatorios, Grafos completos}
            \end{axis}
        \end{tikzpicture}
    \end{figure}

    \begin{figure}[H]
        \centering
        \caption{}
        \label{fig:exp1:k-arios}
        \begin{tikzpicture}
            \begin{axis}[
                    title={},
                    xlabel={$k/M$},
                    ylabel={Tiempo de ejecución (nanosegundos)},
                    scaled x ticks=false,
                    scaled y ticks=false,
                    width=0.5\textwidth,
                    height=0.5\textwidth,
                    legend pos=south east,
                    legend cell align=left,
                ]
                \addplot[color=red]
                    table[x expr={\thisrowno{0}/200000},y index=1]
                    {../exp/UnaNuevaEsperanza-k-arios-m200k};
                \addplot[color=blue]
                    table[x expr={\thisrowno{0}/400000},y index=1]
                    {../exp/UnaNuevaEsperanza-k-arios-m400k};
                \legend{$M=200000$, $M=400000$}
            \end{axis}
        \end{tikzpicture}
    \end{figure}
